#!/usr/bin/env python3
"""
Claude Bot Task Executor
Handles task execution, branch creation, and PR submission
"""

import os
import sys
import json
import subprocess
import argparse
from datetime import datetime
from pathlib import Path

class TaskExecutor:
    def __init__(self, workspace_dir="/workspace", data_dir="/bot/data"):
        self.workspace_dir = workspace_dir
        self.data_dir = Path(data_dir)
        self.queue_dir = self.data_dir / "queue"
        self.completed_dir = self.data_dir / "completed"
        
        # Create directories if they don't exist
        self.queue_dir.mkdir(parents=True, exist_ok=True)
        self.completed_dir.mkdir(parents=True, exist_ok=True)
        
    def run_command(self, cmd, cwd=None):
        """Execute a shell command and return output"""
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                cwd=cwd or self.workspace_dir
            )
            if result.returncode != 0:
                print(f"Error running command: {cmd}")
                print(f"Error output: {result.stderr}")
            return result.returncode == 0, result.stdout, result.stderr
        except Exception as e:
            print(f"Exception running command: {e}")
            return False, "", str(e)
    
    def create_branch(self, task_name):
        """Create a new git branch for the task"""
        branch_name = f"bot/{task_name.lower().replace(' ', '-')}-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        
        # Fetch latest changes
        self.run_command("git fetch origin")
        
        # Create and checkout new branch from main
        success, _, _ = self.run_command(f"git checkout -b {branch_name} origin/main")
        
        if success:
            print(f"Created branch: {branch_name}")
            return branch_name
        return None
    
    def execute_claude_task(self, task_description):
        """Execute task using Claude Code"""
        cmd = f'claude-code --no-interactive "{task_description}"'
        success, output, error = self.run_command(cmd)
        
        if success:
            print("Claude Code executed successfully")
            return True
        else:
            print(f"Claude Code execution failed: {error}")
            return False
    
    def commit_changes(self, task_name):
        """Commit all changes made by Claude"""
        # Stage all changes
        self.run_command("git add -A")
        
        # Check if there are changes to commit
        success, output, _ = self.run_command("git status --porcelain")
        
        if output.strip():
            # Commit with descriptive message
            commit_msg = f"Bot: {task_name}\n\nAutomated changes by Claude Bot"
            success, _, _ = self.run_command(f'git commit -m "{commit_msg}"')
            
            if success:
                print("Changes committed successfully")
                return True
        else:
            print("No changes to commit")
            return False
    
    def create_pull_request(self, branch_name, task_name, task_description):
        """Create a pull request using GitHub CLI"""
        pr_title = f"Bot: {task_name}"
        pr_body = f"""## Automated Task Execution

**Task:** {task_name}
**Description:** {task_description}
**Branch:** {branch_name}
**Executed by:** Claude Bot
**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---
*This PR was automatically generated by Claude Bot*
"""
        
        # Push branch to remote
        success, _, _ = self.run_command(f"git push -u origin {branch_name}")
        
        if success:
            # Create PR
            cmd = f'gh pr create --title "{pr_title}" --body "{pr_body}" --base main'
            success, output, _ = self.run_command(cmd)
            
            if success:
                print(f"Pull request created: {output}")
                return True
        
        return False
    
    def process_task(self, task_file):
        """Process a single task from queue"""
        try:
            # Read task details
            with open(task_file, 'r') as f:
                task = json.load(f)
            
            task_name = task.get('name', 'Unnamed Task')
            task_description = task.get('description', '')
            
            print(f"\nProcessing task: {task_name}")
            print(f"Description: {task_description}")
            
            # Create branch
            branch_name = self.create_branch(task_name)
            if not branch_name:
                raise Exception("Failed to create branch")
            
            # Execute task with Claude
            if not self.execute_claude_task(task_description):
                raise Exception("Failed to execute Claude task")
            
            # Commit changes
            self.commit_changes(task_name)
            
            # Create PR
            if self.create_pull_request(branch_name, task_name, task_description):
                # Move task to completed
                completed_file = self.completed_dir / f"{task_file.stem}_completed.json"
                task['completed_at'] = datetime.now().isoformat()
                task['branch'] = branch_name
                
                with open(completed_file, 'w') as f:
                    json.dump(task, f, indent=2)
                
                # Remove from queue
                os.remove(task_file)
                
                print(f"Task completed successfully: {task_name}")
                return True
            
        except Exception as e:
            print(f"Error processing task: {e}")
            # Return to main branch
            self.run_command("git checkout main")
            return False
    
    def run(self):
        """Main execution loop"""
        print("Claude Bot Task Executor started")
        print(f"Watching queue: {self.queue_dir}")
        
        # Process all tasks in queue
        task_files = list(self.queue_dir.glob("*.json"))
        
        if not task_files:
            print("No tasks in queue")
            return
        
        for task_file in task_files:
            self.process_task(task_file)
            
            # Return to main branch after each task
            self.run_command("git checkout main")

def main():
    parser = argparse.ArgumentParser(description='Claude Bot Task Executor')
    parser.add_argument('--workspace', default='/workspace', help='Workspace directory')
    parser.add_argument('--data', default='/bot/data', help='Bot data directory')
    
    args = parser.parse_args()
    
    executor = TaskExecutor(args.workspace, args.data)
    executor.run()

if __name__ == "__main__":
    main()